#!/usr/bin/perl

use strict;
use warnings;
use utf8;

use Clib::Proc qw|script1 lib|;
use Clib::Const ':utf8';
use Clib::Log 'log_syncd';
use Clib::DB::MySQL 'DB';
use Clib::BinProto;

use IO::Socket;
use IO::Select;
use JSON::XS;
use POSIX qw(WNOHANG);

$SIG{__DIE__} = sub { error('DIE: %s', $_) for @_ };

# Загрузка протокола обмена
my $precv = Clib::BinProto->new(
    '%',
    # Приветствие от устр-ва
    { s => 0x01, code => 'hello',       pk => 'N',      key => 'authid' },
    
    # ожидание join
    { s => 0x12, code => 'joinidle',    pk => 'N',      key => 'timeout' },
    { s => 0x14, code => 'joinfin' },
    
    # приём данных
    { s => 0x21, code => 'datacfg',     pk => 'XCnCCCaaaa',
                                                        key => 'chksum,contrast,timezone,gndmanual,gndauto,dsplautoff,dsplcnp,dsplland,dsplgnd,dsplpwron' },
    { s => 0x22, code => 'datajmp',     pk => 'XN',     key => 'chksum,count' },
    { s => 0x23, code => 'datapntcs',   pk => 'X',      key => 'chksum' },
    { s => 0x24, code => 'datapnt',     pk => 'CCDD',   key => 'num,used,lat,lng' },
    
    { s => 0x31, code => 'datalogbookbeg',pk=>'',       key => '' },
    { s => 0x32, code => 'datalogbook', pk => 'NT' . ('NDDaaDDDnC ' x 3),
        key => 'num,dt,' . join(',',
                        map {
                            my $p=$_.'_';
                            join ',', map { $p.$_ } qw/mill alt vspeed state direct lat lng hspeed hang sat/
                        }
                        qw/beg cnp end/) },
    { s => 0x33, code => 'datalogbookend',pk=>'H',      key => 'chksum' },
    
    { s => 0x34, code => 'datatrackbeg',pk=>'C',        key => 'fnum' },
    { s => 0x35, code => 'datatrack', pk => 'NDDaaDDDnC ',
                                                        key => 'mill,alt,vspeed,state,direct,lat,lng,hspeed,hang,sat' },
    { s => 0x36, code => 'datatrackend',pk=>'H',        key => 'chksum' },
    
    { s => 0x3f, code => 'datafin',     pk=>'',         key => '' },
);
my $phello = Clib::BinProto->new(
    '#',
    { s => 0x0f, code => 'bye',         pk => 'N',      key => 'authid' },
    { s => 0x10, code => 'rejoin',      pk => 'N',      key => 'joinnum' },
    { s => 0x20, code => 'accept',      pk => '',       key => '' }
);

foreach my $p ($precv, $phello) {
    if ($p->error()) {
        error('[proto] %s', $_) foreach $p->error();
        exit -1;
    }
}

# параметры процесса
Clib::Proc::daemon(
    pidfile => (c('pidPath')||'.').'/syncd.pid',
    procname => 'gpstat-syncd',
    no => c('syncd_nodaemon')
) || exit -1;

# серверный сокет
my $sockSrv = IO::Socket::INET->new(
                    Proto => 'tcp',
                    LocalPort => c('syncd_port'),
                    Listen => 10,
                    TimeOut => 4,
                    Reuse => 1,
                );
if (!$sockSrv) {
    error('Can\'t bind TCP port %s: %s', c('syncd_port'), $@);
    exit -1;
}

# сигнал прерывания процесса
Clib::Proc::sigint(sub {
    $sockSrv->close() if $sockSrv;
    undef $sockSrv;
});

log('Starting bind on port %s', c('syncd_port'));

# Преподготовка для форка
my $f = Clib::Proc->forkinit();
$f->onterm(sub {
    my %p = @_;
    debug('Terminated [%d] %s', $p{pid}, $p{ip});
});

# Основной цикл приёма входящих соединений
while ($sockSrv) {
    my $sock = $sockSrv->accept() || next;
    
    my $ip = $sock->peerhost();
    debug('Connect from %s', $ip);
    
    # Лимит по одновременным соединениям
    if (my $cnt = c('syncd_client_count')) {
        if ($f->chldcnt() >= $cnt) {
            error('client count limit exceed');
            $sock->shutdown(2);
            $sock->close();
            next;
        }
    }
    
    # форкаемся
    my $pid = $f->fork(ip => $ip) || return;
    if ($f->ischld()) {
        Clib::Log->prefix($pid . ' - ' . $ip);
        $0 .= ': '.$ip;
        $sockSrv->close();
        undef $sockSrv;
        
        # клиентский процесс
        cli_recv($sock);
        $sock->shutdown(2);
        $sock->close();
        last;
    }
    else {
        $sock->close();
    }
}

log('Finished');

exit 0;

# =========================================================
# чтение команд
# =========================================================

sub cli_recv {
    my $sock = shift;
    
    my $run = 1;
    # сигнал прерывания процесса
    Clib::Proc::sigint(sub { undef $run; });
    
    my $shnd = IO::Select->new($sock);
    
    # приёмник команд
    my $data = ''; # бинарный поток команд
    my @data = (); # распакованный поток команд
    my $hnd = \&hnd_hello; # текущий обработчик команд, он может меняться в процессе
    
    (*$sock)->{reader} = sub {
        $data .= $_[0];
        
        # распаковка
        my $p = $precv->unpack($data);
        if (!$p) {
            # ошибка распаковки
            error('proto error: %s', $_) foreach $precv->error();
            error('proto unknown error') if !$precv->error();
            return;
        }
        
        push @data, @$p;
        # Обрабатываем команды
        while (@data) {
            my $d = shift @data;
            debug('pkt: %s', $d->{code});
            my $ok = $hnd->($sock, $d, $hnd, $shnd);
            if (!$ok) {
                # обработчик вернул ошибку
                error('pkt hnd fail on: %s', $d->{code});
                return;
            }
            if (!defined($hnd)) {
                undef $run;
                last;
            }
        }
        
        1;
    };
    
    my $timeout = c('syncd_timeout');
    my $tout = time() + $timeout;
    while ($run && $sock && $shnd && $shnd->handles()) {
        my @sock = $shnd->can_read(1);
        
        foreach my $s (@sock) {
            $run || last;
            my $buf; #  получение из сокета
            my $r = $s->recv($buf, 1024);
            if (!defined($r)) {
                error('sock recv fail: %s', $!);
                shnd_remove($shnd, $s);
                next;
            }
            
            my $err = '';
            my $ok = (*$s)->{reader}->($buf, $err);
            if (!$ok) {
                error('sock reader fail: %s', $err) if $err;
                undef $run;
                last;
            }
            
            $tout = time() + $timeout;
        }
        
        if ($tout < time()) {
            log('client read timeout');
            last;
        }
    }
    
    shnd_remove($shnd, $shnd->handles());
}

sub shnd_remove {
    my $shnd = shift;
    
    foreach my $s (@_) {
        $shnd->remove($s);
        $s->shutdown(2);
        $s->close();
        if (my $d = (*$s)->{destroy}) {
            $d->();
        }
    }
}

# =========================================================
#  Приветствие, инициализация
# =========================================================
sub hnd_hello {
    my ($sock, $d) = @_;
    my $lpref = log_prefix('hnd_hello');
    dumper 'recv' => $d;
    
    if ($d->{code} eq 'hello') {
        my $authid = $d->{authid}
            || return do_join(@_);
        my $dev = sqlGet(device => authid => $authid)
            || return do_join(@_);
        dumper dev => $dev;
        
        $sock->send($phello->pack( accept => { } ));
        $_[2] = \&hnd_data;
    }
    else {
        return;
    }
    
    1;
}

# Инициализация процедуры подключения устройства веб-порталу
sub do_join {
    my ($sock, $d, $hnd, $shnd) = @_;
    
    my $sockjoin = c('sockjoin');
    if (!$sockjoin) {
        error('Const `sockjoin` not defined');
        return;
    }
    
    # Генерация  join-num
    # Проще всего это сделать отсюда, чтобы создать сокет
    # с номером в имени файла. Так вебу будет просто и быстро определить,
    # есть ли такой номер, заодно убедимся в уникальности номера
    my $joinnum;
    my $f;
    
    while (!$f || (-e $f)) {
        $joinnum = rand 0xffff;
        if (!$joinnum || ($joinnum == 0xffff) || ($joinnum == 0xefff)) {
            error('Can\'t gen join-num');
            return;
        }
        $f = sprintf $sockjoin, $joinnum;
    }
    
    # Создаём udp-сокет, который будет только перенаправлять
    # пакеты в устр-во, это надо для отправки кода подтверждения.
    # В случае совпадения номера, устр-во в ответ отправит команду
    # об успешном подтверждении номера
    my $s = 
        IO::Socket::UNIX->new (
            Local   => $f,
            Type    => SOCK_DGRAM,
            ReuseAddr => 1,
        );
    if (!$s) {
        error('Can\'t create join-sock \'%s\': %s', $f, $!);
        return;
    }
    (*$s)->{reader} = sub {
        debug('Recv from udp %d bytes', length($_[0]));
        $sock->send($_[0]);
    };
    
    (*$s)->{destroy} = sub {
        unlink($f) ?
            debug('join-sock removed ok: %s', $f) :
            error('join-sock removed fail \'%s\': %s', $f, $!);
    };
    
    $shnd->add($s);
    
    $_[2] = \&hnd_join;
    $sock->send($phello->pack( rejoin => { joinnum => $joinnum } ));
    
    1;
}

# =========================================================
#  Подключение устройства к вебу
# =========================================================
sub hnd_join {
    my ($sock, $d, undef, $shnd) = @_;
    my $lpref = log_prefix('hnd_join');
    
    return 1 if $d->{code} eq 'joinidle';
    
    if ($d->{code} eq 'joinfin') {
        $_[2] = \&hnd_hello;
        shnd_remove($shnd, grep { $_ ne $sock } $shnd->handles());
        debug('join fin');
    }
    else {
        return;
    }
    
    1;
}

# =========================================================
#  Приём данных
# =========================================================
sub hnd_data {
    my ($sock, $d) = @_;
    my $lpref = log_prefix('hnd_data');
    dumper 'recv' => $d;
    
    if ($d->{code} eq 'datafin') {
        debug('recv data fin: send bye and terminate');
        $sock->send($phello->pack( bye => {} ));
        $_[2] = undef;
    }
    
    1;
}

#==========================================================
#================================================== End ===
#==========================================================
